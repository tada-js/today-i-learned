### 헷갈렸던 개념들 복습

#### 2022.06.09

- 자바스크립트의 자료형
  - Primitive Type(원시 타입)
    - `let number = 12;`
    - 한 번에 하나의 값만 가질 수 있다
    - 하나의 고정된 저장 공간 이용
  - Non-Primitive Type(비 원시 타입)
    - `let array = [1, 2, 3, 4];`
    - 한 번에 여러 개의 값을 가질 수 있다
    - 여러 개의 고정되지 않은 동적 공간 사용
- 자바스크립트 표기법

  ```tsx
  let person = {
    key1: "value1", // 프로퍼티 (객체 프로퍼티)
    key2: "value2",
  }; // 객체 리터럴 방식

  console.log(person.key1); // 점 표기법
  console.log(person["key2"]); // 괄호 표기법
  ```

  - 점 표기법
    - `person.key1`
    - 장점: 간결하게 작성 가능, 가독성 측면에서 유리
  - 괄호 표기법
    - `person.["key2"]`
    - 장점: 객체의 프로퍼티에 변수를 활용하여 접근할 수 있음.
  - 점 표기법의 한계
    - `object.property = changingValue` 에러 발생
  - 점 표기법의 한계를 괄호 표기법으로 극복

    - `object[property] = changingValue` 프러퍼티에 접근 가능

    ```tsx
    let person = {
      key1: "value1", // 프로퍼티 (객체 프로퍼티)
      key2: "value2",
    }; // 객체 리터럴 방식

    console.log(person.key1); // 점 표기법
    console.log(person["key2"]); // 괄호 표기법
    console.log(getPropertyValue("key2"));

    function getPropertyValue(key) {
      return person[key];
    }
    ```

  - 비동기 데이터에서 괄호 표기법
    - 괄호 표기법을 통해 객체 내부가 정의되지 않은 경우에도 접근할 수 있는 이점이 있다.
    - 예를 들어 API 통신으로 어떤 객체(=result)를 받아올 때, 해당 객체의 내부 값을 변경하는 코드를 작성한다고 가정한다면 result 객체의 a 라는 프로퍼티가 존재해도, API 통신 이전에는 해당 프로퍼티는 정의되지 않은 상태다. 점 표기법으로는 정의되지 않은 result 객체에 접근할 수 없지만, 괄호 표기법은 해당 프로퍼티를 변수화하기 때문에 접근이 가능해진다.
    - 따라서 비동기로 데이터를 호출하는 경우, 프로퍼티에 접근하고 싶다면 괄호 표기법을 사용하자.

- `const person = {}` 처럼 let이 아닌 const를 쓰고 객체를 수정하면 에러가 발생할 것 같지만, 실제로는 발생하지 않는다. person의 object를 수정하는 것이지 person 자체를 수정하는 것이 아니기 때문이다.
  - person 자체를 수정한다는 것은 `person = {}` 와 같이 재정의 하는 것!
- 객체 안에 프로퍼티가 정의되어 있는지 확인하는 방법

  ```tsx
  let person = {
    key1: "value1", // 멤버
    key2: "value2", // 멤버
  };

  console.log(`key1: ${"key1" in person}`);
  console.log(`key3: ${"key3" in person}`);
  ```

- 반복문을 사용해서 객체 프로퍼티 접근

  ```tsx
  let person = {
    key1: "1",
    key2: "2",
  };

  const personKeys = Object.keys(person);
  const personValues = Object.values(person);

  for (let i = 0; i < personKeys.length; i++) {
    const curKey = personKeys[i];
    const curValue = person[curKey];

    console.log(`${curKey} : ${curValue}`);
  }

  for (let i = 0; i < personValues.length; i++) {
    console.log(personValues[i]);
  }
  ```

- 배열 내장 함수

  - forEach

    ```tsx
    const arr = [1, 2, 3, 4];
    const newArr = [];

    arr.forEach(function (elm) {
      newArr.push(elm * 2);
    });
    // (4) [2, 4, 6, 8]
    ```

  - map

    ```tsx
    const arr = [1, 2, 3, 4];
    const newArr = arr.map((elm) => {
      return elm * 2;
    });

    console.log(newArr);
    // (4) [2, 4, 6, 8]
    ```

  - includes

    ```tsx
    const arr = [1, 2, 3, 4];
    let number = 3;

    console.log(arr.includes(number));
    // true
    ```

  - indexOf

    ```tsx
    const arr = [1, 2, 3, 4];
    let number = 3;

    console.log(arr.indexOf(number));
    // 2
    ```

  - findIndex

    ```tsx
    const arr = [{ color: "red" }, { color: "blue" }, { color: "green" }];

    console.log(arr.findIndex((elm) => elm.color === "blue"));
    // 1
    ```

  - find

    ```tsx
    const arr = [{ color: "red" }, { color: "blue" }, { color: "green" }];

    const element = arr.find((elm) => elm.color === "blue");
    console.log(element);
    ```

  - filter

    ```tsx
    const arr = [
      { num: 1, color: "red" },
      { num: 2, color: "black" },
      { num: 3, color: "blue" },
    ];

    console.log(arr.filter((elm) => elm.color === "blue"));
    ```

  - slice

    ```tsx
    const arr = [
      { num: 1, color: "red" },
      { num: 2, color: "black" },
      { num: 3, color: "blue" },
    ];

    console.log(arr.slice(0, 2));
    ```

  - concat

    ```tsx
    const arr1 = [
      { num: 1, color: "red" },
      { num: 2, color: "black" },
      { num: 3, color: "blue" },
    ];

    const arr2 = [
      { num: 4, color: "green" },
      { num: 5, color: "blue" },
    ];

    console.log(arr1.concat(arr2));
    ```

  - sort (원본 배열의 데이터를 정렬)

    ```tsx
    let chars = ["나", "다", "가"];

    chars.sort();

    console.log(chars);
    ```

  - sort(숫자형 오름차순 정렬)

    ```tsx
    let numbers = [0, 1, 2, 10, 30, 20, 3];

    const compare = (a, b) => {
      // 1. 같다
      // 2. 크다
      // 3. 작다

      if (a > b) {
        // 크다
        return 1;
      }
      if (a < b) {
        // 작다
        return -1;
      }

      // 같다
      return 0;
    };

    numbers.sort(compare);

    console.log(numbers);
    ```

  - sort(숫자형 내림차순 정렬)

    ```tsx
    let numbers = [0, 1, 2, 10, 30, 20, 3];

    const compare = (a, b) => {
      // 1. 같다
      // 2. 크다
      // 3. 작다

      if (a > b) {
        // 크다
        return -1;
      }
      if (a < b) {
        // 작다
        return 1;
      }

      // 같다
      return 0;
    };

    numbers.sort(compare);

    console.log(numbers);
    ```

  - join(문자열 하나로 합쳐짐)
